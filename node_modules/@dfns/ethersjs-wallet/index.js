"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DfnsWallet = void 0;
const Wallets_1 = require("@dfns/sdk/codegen/datamodel/Wallets");
const ethers_1 = require("ethers");
const sleep = (interval = 0) => new Promise((resolve) => setTimeout(resolve, interval));
class DfnsWallet extends ethers_1.AbstractSigner {
    constructor(options, provider) {
        var _a, _b;
        super(provider);
        this.options = {
            ...options,
            maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : 3,
            retryInterval: (_b = options.retryInterval) !== null && _b !== void 0 ? _b : 1000,
        };
    }
    connect(provider) {
        return new DfnsWallet(this.options, provider);
    }
    async getAddress() {
        if (!this.address) {
            const { walletId, dfnsClient } = this.options;
            const res = await dfnsClient.wallets.getWallet({ walletId });
            (0, ethers_1.assertArgument)(res.address, 'wallet does not have an address', 'walletId', walletId);
            this.address = (0, ethers_1.getAddress)(res.address);
        }
        return this.address;
    }
    async waitForSignature(signatureId) {
        var _a;
        const { walletId, dfnsClient, retryInterval } = this.options;
        let maxRetries = this.options.maxRetries;
        while (maxRetries > 0) {
            await sleep(retryInterval);
            const res = await dfnsClient.wallets.getSignature({ walletId, signatureId });
            if (res.status === Wallets_1.SignatureStatus.Signed) {
                if (!((_a = res.signature) === null || _a === void 0 ? void 0 : _a.encoded))
                    break;
                return res.signature.encoded;
            }
            else if (res.status === Wallets_1.SignatureStatus.Failed) {
                break;
            }
            maxRetries -= 1;
        }
        throw new Error(`signature ${signatureId} not available`);
    }
    async signTransaction(tx) {
        // replace any Addressable or ENS name with an address
        const { to, from } = await (0, ethers_1.resolveProperties)({
            to: tx.to ? (0, ethers_1.resolveAddress)(tx.to, this.provider) : undefined,
            from: tx.from ? (0, ethers_1.resolveAddress)(tx.from, this.provider) : undefined,
        });
        if (to != null) {
            tx.to = to;
        }
        if (from != null) {
            tx.from = from;
        }
        if (tx.from != null) {
            (0, ethers_1.assertArgument)((0, ethers_1.getAddress)(tx.from) === (await this.getAddress()), 'transaction from address mismatch', 'tx.from', tx.from);
            delete tx.from;
        }
        // sign the digest and build the transaction
        const btx = ethers_1.Transaction.from(tx);
        const { walletId, dfnsClient } = this.options;
        const res = await dfnsClient.wallets.generateSignature({
            walletId,
            body: { kind: Wallets_1.SignatureKind.Hash, hash: btx.unsignedHash },
        });
        btx.signature = await this.waitForSignature(res.id);
        return btx.serialized;
    }
    async signMessage(message) {
        const { walletId, dfnsClient } = this.options;
        const res = await dfnsClient.wallets.generateSignature({
            walletId,
            body: { kind: Wallets_1.SignatureKind.Hash, hash: (0, ethers_1.hashMessage)(message) },
        });
        return this.waitForSignature(res.id);
    }
    async signTypedData(domain, types, value) {
        var _a, _b, _c;
        const { walletId, dfnsClient } = this.options;
        const res = await dfnsClient.wallets.generateSignature({
            walletId,
            body: {
                kind: Wallets_1.SignatureKind.Eip712,
                types,
                domain: {
                    name: (_a = domain.name) !== null && _a !== void 0 ? _a : undefined,
                    version: (_b = domain.version) !== null && _b !== void 0 ? _b : undefined,
                    chainId: domain.chainId ? Number(domain.chainId) : undefined,
                    verifyingContract: (_c = domain.verifyingContract) !== null && _c !== void 0 ? _c : undefined,
                    salt: domain.salt ? (0, ethers_1.hexlify)(domain.salt) : undefined,
                },
                message: value,
            },
        });
        return this.waitForSignature(res.id);
    }
}
exports.DfnsWallet = DfnsWallet;
