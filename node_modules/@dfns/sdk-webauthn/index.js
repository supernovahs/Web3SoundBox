"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebAuthn = exports.DEFAULT_WAIT_TIMEOUT = void 0;
const base64_1 = require("@dfns/sdk/utils/base64");
const buffer_1 = require("buffer");
exports.DEFAULT_WAIT_TIMEOUT = 60000;
class WebAuthn {
    constructor(options) {
        this.options = options;
    }
    async sign(challenge, allowCredentials) {
        var _a;
        const credential = (await navigator.credentials.get({
            mediation: 'required',
            publicKey: {
                challenge: buffer_1.Buffer.from(challenge),
                allowCredentials: allowCredentials.webauthn.map(({ id, type, transports }) => ({
                    id: (0, base64_1.fromBase64Url)(id),
                    type,
                    transports: transports !== null && transports !== void 0 ? transports : [],
                })),
                rpId: this.options.rpId,
                userVerification: 'required',
                timeout: (_a = this.options.timeout) !== null && _a !== void 0 ? _a : exports.DEFAULT_WAIT_TIMEOUT,
            },
        }));
        if (!credential) {
            throw new Error('Failed to sign with WebAuthn credential');
        }
        const assertion = credential.response;
        return {
            kind: 'Fido2',
            credentialAssertion: {
                credId: credential.id,
                clientData: (0, base64_1.toBase64Url)(buffer_1.Buffer.from(assertion.clientDataJSON)),
                authenticatorData: (0, base64_1.toBase64Url)(buffer_1.Buffer.from(assertion.authenticatorData)),
                signature: (0, base64_1.toBase64Url)(buffer_1.Buffer.from(assertion.signature)),
                userHandle: assertion.userHandle ? (0, base64_1.toBase64Url)(buffer_1.Buffer.from(assertion.userHandle)) : '',
            },
        };
    }
    async create(challenge) {
        var _a;
        const options = {
            publicKey: {
                challenge: buffer_1.Buffer.from(challenge.challenge),
                pubKeyCredParams: challenge.pubKeyCredParams,
                rp: challenge.rp,
                user: {
                    displayName: challenge.user.displayName,
                    id: buffer_1.Buffer.from(challenge.user.id),
                    name: challenge.user.name,
                },
                attestation: challenge.attestation,
                excludeCredentials: challenge.excludeCredentials.map((cred) => {
                    var _a;
                    return ({
                        id: (0, base64_1.fromBase64Url)(cred.id),
                        type: cred.type,
                        transports: (_a = cred.transports) !== null && _a !== void 0 ? _a : [],
                    });
                }),
                authenticatorSelection: challenge.authenticatorSelection,
                timeout: (_a = this.options.timeout) !== null && _a !== void 0 ? _a : exports.DEFAULT_WAIT_TIMEOUT,
            },
        };
        const response = await navigator.credentials.create(options);
        if (response === null) {
            throw Error(`Failed to create and sign with WebAuthn credential`);
        }
        const credential = response;
        const attestation = credential.response;
        return {
            credentialKind: 'Fido2',
            credentialInfo: {
                credId: credential.id,
                attestationData: (0, base64_1.toBase64Url)(buffer_1.Buffer.from(attestation.attestationObject)),
                clientData: (0, base64_1.toBase64Url)(buffer_1.Buffer.from(attestation.clientDataJSON)),
            },
        };
    }
}
exports.WebAuthn = WebAuthn;
