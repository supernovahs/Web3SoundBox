import { Amount, AssetSymbol, DfnsCertificate, EntityId, Initiator, IntegerPositiveStrict, IsoDatetime, PublicKey, Tag } from '../Foundations';
export type PaymentInitiation = {
    id: EntityId;
    paymentId: EntityId;
    externalId?: EntityId;
    status: PaymentInitiationStatus;
    orgId?: EntityId;
    initiator: Initiator;
    assetSymbol: AssetSymbol;
    amount: Amount;
    sender: DfnsAssetAccount;
    receiver: PaymentInstrument;
    dateInitiated: IsoDatetime;
    /**
     * In case payment initiation is rejected by the system, this field will contain information about it.
     *
     */
    rejectionReason?: string;
};
export type BlockchainWalletAddress = {
    kind: PaymentInstrumentKind.BlockchainWalletAddress;
    address: string;
};
export type DfnsAssetAccount = {
    kind: PaymentInstrumentKind.DfnsAssetAccount;
    id: EntityId;
};
export type AssetAccount = {
    /**
     * Multiple tags can be attached to an entity to categorise or otherwise mark it. For example tags could indicate risk (High, Medium, Low), departments (Trading, Sales, IT), purpose (Treasury, Hot, Deposits), and jurisdictions (US, EU, DE).
     *
     * Multiple tags can be attached to same entity.
     */
    tags?: Tag[];
    /**
     * Field can be used if entity is created in external (customer’s) system first. This way the external id can be attached to identify entity from Dfns’s data store.
     */
    externalId?: string;
    /**
     * Indicates id of the Organisation, such as usually a customer, or sub-devision, sub-tenant, and others.
     */
    orgId: EntityId;
    id: EntityId;
    /**
     * Indicates whether account is ready to be used.
     */
    status: AssetAccountStatus;
    /**
     * Blockchain address for a chosen Blockchain network.
     */
    address?: string;
    /**
     * `PublicKey` which is used by `AssetAccount`. Usually this is used to derive addresses on a given blockchain network.
     *
     * Alternatively can be used to verify signatures produced by the platform.
     */
    publicKey?: string;
    publicKeyId?: EntityId;
    /**
     * # [ENUM]
     *
     * Asset symbol indicating which asset this account is managing. BTC or ETH are obvious examples, but there are thousands of possible symbols. In case of coins (ERC20 and alike) use `COIN.BLOCKCHAIN` syntax, such as USDC.ETH or USDC.SOL to indicate that USDC on Ethereum or USDC on Solana is required. To get a list of all allowed values, send a `CreateAssetAccount` request with the `assetSymbol` field empty.
     */
    assetSymbol: AssetSymbol;
    /**
     * Custom name that can be added for an account.
     */
    name: string;
    dateCreated: IsoDatetime;
    dateUpdate: IsoDatetime;
    authorizations?: AssetAccountAuthorization[];
};
export type Payment = {
    /**
     * Multiple tags can be attached to an entity to categorise or otherwise mark it. For example tags could indicate risk (High, Medium, Low), departments (Trading, Sales, IT), purpose (Treasury, Hot, Deposits), and jurisdictions (US, EU, DE).
     *
     * Multiple tags can be attached to same entity.
     */
    tags?: Tag[];
    /**
     * Field can be used if entity is created in external (customer’s) system first. This way the external id can be attached to identify entity from Dfns’s data store.
     */
    externalId?: string;
    /**
     * Indicates id of the Organisation, such as usually a customer, or sub-devision, sub-tenant, and others.
     */
    orgId: EntityId;
    id: EntityId;
    status: PaymentStatus;
    initiator: Initiator;
    assetAccountId: EntityId;
    assetSymbol: AssetSymbol;
    amount: Amount;
    sender: PaymentInstrument;
    receiver: PaymentInstrument;
    /**
     * SWIFT (MT, ISO15022) field. Represents additional information about payment.
     *
     */
    narrative?: string;
    note?: string;
    receiverAddress: string;
    policyCertificate?: DfnsCertificate;
    dateCreated: IsoDatetime;
    dateUpdated: IsoDatetime;
    dateExecuted?: IsoDatetime;
    dateBroadcasted?: IsoDatetime;
    dateFirstConfirmed?: IsoDatetime;
    dateConfirmed?: IsoDatetime;
    dateSettled?: IsoDatetime;
    txHash?: string;
    blockHeight?: number;
    direction: PaymentDirection;
    fee?: Amount;
};
export type AssetAccountAuthorization = {
    kind: AssetAccountAuthorizationKind;
    entityId: EntityId;
    permission: AssetAccountPermissions;
};
/**
 * Balance of one asset account.
 */
export type AssetAccountBalance = {
    /**
     * Id of the AssetAccount.
     */
    id: EntityId;
    /**
     * Asset Symbol of the account.
     */
    assetSymbol: AssetSymbol;
    /**
     * Balance of the account.
     */
    balance: Amount;
    maxUnitBalance: Amount;
};
export type UpdateAssetAccountPayload = {
    /**
     * Indicates whether account is ready to be used.
     */
    status: AssetAccountStatus;
    /**
     * Blockchain address for a chosen Blockchain network.
     */
    address?: string;
    /**
     * `PublicKey` which is used by `AssetAccount`. Usually this is used to derive addresses on a given blockchain network.
     *
     * Alternatively can be used to verify signatures produced by the platform.
     */
    publicKey?: string;
    /**
     * Custom name that can be added for an account.
     */
    name?: string;
};
export type CreateAssetAccountInput = {
    /**
     * # [ENUM]
     *
     * Asset symbol indicating which asset this account is managing. BTC or ETH are obvious examples, but there are thousands of possible symbols. In case of coins (ERC20 and alike) use `COIN.BLOCKCHAIN` syntax, such as USDC.ETH or USDC.SOL to indicate that USDC on Ethereum or USDC on Solana is required. To get a list of all allowed values, send a `CreateAssetAccount` request with the `assetSymbol` field empty.
     */
    assetSymbol: AssetSymbol;
    groupSize?: IntegerPositiveStrict;
    groupThreshold?: IntegerPositiveStrict;
    /**
     * `PublicKey` which is used by `AssetAccount`. Usually this is used to derive addresses on a given blockchain network.
     *
     * Alternatively can be used to verify signatures produced by the platform.
     */
    publicKey?: PublicKey;
    externalId?: string;
    tags?: Tag[];
    /**
     * Custom name that can be added for an account.
     */
    name?: string;
};
export type CreatePaymentInput = {
    externalId?: string;
    assetSymbol: AssetSymbol;
    amount: Amount;
    receiver: PaymentInstrument;
    note?: string;
    narrative?: string;
};
export type PaymentInstrument = BlockchainWalletAddress | DfnsAssetAccount;
export declare enum PaymentInstrumentKind {
    DfnsAssetAccount = "DfnsAssetAccount",
    BlockchainWalletAddress = "BlockchainWalletAddress"
}
export declare enum PaymentInitiationStatus {
    Initiated = "Initiated",
    Canceled = "Canceled",
    Rejected = "Rejected"
}
export declare enum AssetAccountStatus {
    Creating = "Creating",
    Enabled = "Enabled",
    Failed = "Failed"
}
export declare enum PaymentStatus {
    Initiated = "Initiated",
    Rejected = "Rejected",
    Approved = "Approved",
    Executed = "Executed",
    Failed = "Failed",
    Confirmed = "Confirmed"
}
export declare enum AssetAccountAuthorizationKind {
    Employee = "Employee",
    Group = "Group",
    ApiKey = "ApiKey"
}
export declare enum AssetAccountPermissions {
    InitiatePayments = "InitiatePayments",
    ReadBalance = "ReadBalance",
    ReadPublicKey = "ReadPublicKey"
}
export declare enum PaymentDirection {
    Incoming = "Incoming",
    Outgoing = "Outgoing"
}
