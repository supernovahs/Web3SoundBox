import { Amount, AssetSymbol, EntityId, IntegerPositiveStrict, IsoDatetime, Tag, Username } from '../Foundations';
export type Policy = {
    id: EntityId;
    version: string;
    activityKind: PolicyActivityKind;
    tags?: Tag[];
    dateCreated: IsoDatetime;
    orgId: EntityId;
    description?: string;
    author: Username;
    name?: string;
    status: PolicyStatus;
    controlIds: EntityId[];
    ruleIds: EntityId[];
    filter?: PolicyObjectFilter;
};
export type NotifyAndAuditPcConf = {
    kind: PolicyControlKind.NotifyAndAudit;
    usernames?: string[];
    groups?: string[];
};
export type RequestApprovalPcConf = {
    kind: PolicyControlKind.RequestApproval;
    approverGroups?: string[];
    approverUsernames?: string[];
    numApprovals: number;
    timeoutInMinutes?: IntegerPositiveStrict;
};
export type PolicyRule = {
    id: EntityId;
    version: string;
    kind: PolicyRuleKind;
    tags?: Tag[];
    dateCreated: IsoDatetime;
    orgId: EntityId;
    author: Username;
    description?: string;
    name?: string;
    configuration: PolicyRuleConfiguration;
    status: PolicyRuleStatus;
};
export type PolicyControl = {
    id: EntityId;
    version: string;
    kind: PolicyControlKind;
    tags?: Tag[];
    dateCreated: IsoDatetime;
    orgId: EntityId;
    author: Username;
    description?: string;
    name?: string;
    /**
     * Indicates whether control should merge with same one (compared by values).
     * This property should not be set to true, unless outcomes are understood. For example: Let's say we have 3 policies:
     *
     * 1. policy to require approval for payments over â‚¬5000
     * 1. policy to require approval for payments done out of office hours
     * 1. policy to require approval for payments done out of Geofence.
     *
     * In this case policies will require 3 approvals combined, which might not be an intent, and only one approval is required.
     */
    shouldMergeWithSameControl: boolean;
    configuration: PolicyControlConfiguration;
    status: PolicyControlStatus;
};
export type CreateAmountLimitPrConf = {
    kind: PolicyRuleKind.PaymentAmountLimit;
    limit: Amount;
    assetSymbol: AssetSymbol;
    shouldIgnoreAssetsWithoutMarketValue: boolean;
};
export type UpdateAmountLimitPrConf = {
    limit?: Amount;
    assetSymbol?: AssetSymbol;
    shouldIgnoreAssetsWithoutMarketValue?: boolean;
};
export type AmountLimitPrConf = {
    limit: Amount;
    assetSymbol: AssetSymbol;
    shouldIgnoreAssetsWithoutMarketValue: boolean;
};
export type CreateRequestApprovalPcConf = {
    kind: PolicyControlKind.RequestApproval;
    approverUsernames?: string[];
    approverGroups?: string[];
    timeoutInMinutes?: IntegerPositiveStrict;
    numApprovals: number;
};
export type UpdateRequestApprovalPcConf = {
    approverUsernames?: string[];
    approverGroups?: string[];
    timeoutInMinutes?: number;
    numApprovals?: number;
};
export type CreateNotifyAndAuditPcConf = {
    kind: PolicyControlKind.NotifyAndAudit;
    usernames?: string[];
    groups?: string[];
};
export type UpdateNotifyAndAuditPcConf = {
    groups?: string[];
    usernames?: string[];
};
export type PolicyManagementPreferences = {
    /**
     * Sets default `AssetSymbol` for the policy rules that use it, such as Limit, Velocity, Siphoning, and others.
     */
    policyRuleAssetSymbol?: boolean;
};
export type Create = {};
export type EmptyConfiguration = {};
export type CreateAlwaysActivatedPrConf = {
    kind: PolicyRuleKind.AlwaysActivated;
};
export type UpdateAlwaysActivatedPrConf = {};
export type AssetAccountFilter = {
    kind: PolicyObjectFilterKind.AssetAccount;
    assetAccountIds?: EntityId[];
    tags?: Tag[];
    assetSymbols?: string[];
};
export type PublicKeyFilter = {
    kind: PolicyObjectFilterKind.PublicKey;
    publicKeyIds?: EntityId[];
    tags?: string[];
};
export type CreatePolicyInput = {
    activityKind: PolicyActivityKind;
    description: string;
    name?: string;
    controlIds: EntityId[];
    ruleIds: EntityId[];
    status: PolicyStatus;
    filter?: PolicyObjectFilter;
    isImmutable?: boolean;
};
export type UpdatePolicyInput = {
    description?: string;
    controlIds?: EntityId[];
    ruleIds?: EntityId[];
    status?: PolicyStatus;
    filter?: PolicyObjectFilter;
};
export type CreatePolicyControlInput = {
    description?: string;
    name?: string;
    configuration: CreatePolicyControlConfiguration;
    isImmutable?: boolean;
};
export type UpdatePolicyControlInput = {
    description?: string;
    name?: string;
    configuration?: UpdatePolicyControlConfiguration;
};
export type CreatePolicyRuleInput = {
    description?: string;
    name?: string;
    configuration: CreatePolicyRuleConfiguration;
    isImmutable?: boolean;
};
export type UpdatePolicyRuleInput = {
    description?: string;
    name?: string;
    configuration: UpdatePolicyRuleConfiguration;
};
export type CreatePolicyRuleConfiguration = CreateAmountLimitPrConf | CreateAlwaysActivatedPrConf;
export type UpdatePolicyRuleConfiguration = UpdateAmountLimitPrConf | UpdateAlwaysActivatedPrConf;
export type UpdatePolicyControlConfiguration = UpdateRequestApprovalPcConf | UpdateNotifyAndAuditPcConf;
export type CreatePolicyControlConfiguration = CreateRequestApprovalPcConf | CreateNotifyAndAuditPcConf;
export type PolicyRuleConfiguration = AmountLimitPrConf | EmptyConfiguration;
export type PolicyControlConfiguration = NotifyAndAuditPcConf | RequestApprovalPcConf;
export type PolicyObjectFilter = AssetAccountFilter | PublicKeyFilter;
export declare enum PolicyActivityKind {
    CreatingSignature = "CreatingSignature",
    TransactionInitiation = "TransactionInitiation",
    PaymentInitiation = "PaymentInitiation",
    WalletTransferAsset = "WalletTransferAsset",
    WalletBroadcastTransaction = "WalletBroadcastTransaction",
    WalletGenerateSignature = "WalletGenerateSignature"
}
export declare enum PolicyStatus {
    Enabled = "Enabled",
    Disabled = "Disabled",
    Archived = "Archived"
}
/**
 * enumm:
 * * NotifyAndAudit
 * * RequestApproval
 */
export declare enum PolicyControlKind {
    NotifyAndAudit = "NotifyAndAudit",
    RequestApproval = "RequestApproval"
}
export declare enum PolicyRuleKind {
    AlwaysActivated = "AlwaysActivated",
    PaymentAmountLimit = "PaymentAmountLimit",
    TransferAmountLimit = "TransferAmountLimit"
}
export declare enum PolicyControlStatus {
    Enabled = "Enabled",
    Archived = "Archived"
}
export declare enum PolicyRuleStatus {
    Enabled = "Enabled",
    Archived = "Archived"
}
export declare enum PolicyObjectFilterKind {
    AssetAccount = "AssetAccount",
    PublicKey = "PublicKey",
    Wallet = "Wallet"
}
