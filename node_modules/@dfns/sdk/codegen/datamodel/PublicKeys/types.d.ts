import { Amount, BlockchainAddress, BlockchainNetwork, DocumentSnapshot, EntityId, Initiator, IntegerPositiveStrict, IsoDatetime, PublicKey, Tag } from '../Foundations';
export type SignatureResponse = {
    r: string;
    s: string;
    recid: number;
};
export type PublicKeyRecord = {
    id: EntityId;
    externalId?: string;
    orgId: EntityId;
    publicKey: PublicKey;
    signerIds: string[];
    groupThreshold: number;
    groupSize: number;
    tags?: Tag[];
    isEddsa: boolean;
};
export type GetPublicKeyAddressResponse = {
    publicKeyId: string;
    network: string;
    address: BlockchainAddress;
};
export type Signature = {
    id: EntityId;
    orgId: EntityId;
    publicKeyId: string;
    hash: string;
    r: string;
    s: string;
    recid: number;
    status: SignatureStatus;
    initiator: Initiator;
    dateCreated: IsoDatetime;
};
export type CosmosDenomAmount = {
    denom: string;
    amount: string;
};
export type CosmosTimeoutHeight = {
    revisionNumber: string;
    revisionHeight: string;
};
export type EvmGenericTx = {
    templateKind: TransactionTemplateKind.EvmGenericTx;
    to: string;
    gasLimit: Amount;
    gasPrice: Amount;
    nonce?: string;
    value?: string;
    data?: string;
    publicKeyId?: string;
    network: BlockchainNetwork;
    /**
     * the maximum amount of gas to be included as a tip to the miner
     */
    maxPriorityFeePerGas?: Amount;
    /**
     * the maximum amount of gas willing to be paid for the transaction (inclusive of baseFeePerGas and maxPriorityFeePerGas)
     */
    maxFeePerGas?: Amount;
    typedData?: Eip712TypedData;
};
export type CosmosIbcTransferTx = {
    templateKind: TransactionTemplateKind.CosmosIbcTransfer;
    sourcePort: string;
    sourceChannel: string;
    token: CosmosDenomAmount;
    sender: string;
    receiver: string;
    timeoutHeight: CosmosTimeoutHeight;
    timeoutTimestamp: string;
    publicKeyId?: string;
    network: BlockchainNetwork;
};
export type Eip712TypedData = {
    types: Record<string, unknown>;
    values: Record<string, unknown>;
    domain?: Eip712TypedDataDomain;
};
export type Eip712TypedDataDomain = {
    name?: string;
    chainId?: string;
    version?: string;
    verifyingContract?: string;
    salt?: string;
};
export type SolanaTxInstruction = {
    data: string;
    programId: string;
    keys: SolanaTxAccountMeta[];
};
export type SolanaTx = {
    feePayer?: string;
    blockhash?: string;
    lastValidBlockHeight?: IntegerPositiveStrict;
    minNonceContextSlot?: IntegerPositiveStrict;
    instructions: SolanaTxInstruction[];
    signatures?: SolanaTxSignature[];
    templateKind: TransactionTemplateKind.SolanaTx;
};
export type SolanaTxSignature = {
    signature: string;
    publicKey: string;
};
export type SolanaTxAccountMeta = {
    pubkey: string;
    isSigner: boolean;
    isWritable: boolean;
};
export type TronTx = {
    visible?: boolean;
    txID?: string;
    contract_address?: string;
    raw_data_hex?: string;
    raw_data: Record<string, unknown>;
    templateKind: TransactionTemplateKind.TronTx;
};
export type TezosTx = {
    protocol?: string;
    chain?: string;
    block?: string;
    payload: TezosTxPayload;
    templateKind: TransactionTemplateKind.TezosTx;
};
export type TezosTxPayload = {
    branch?: string;
    contents: Record<string, unknown>[];
};
export type BroadcastedTransaction = {
    id: EntityId;
    transaction: TransactionPayload;
    snapshot: DocumentSnapshot;
    network: BlockchainNetwork;
    dateCreated: IsoDatetime;
    dateUpdated: IsoDatetime;
    status: TransactionStatus;
    txHash?: string;
    networkResponse?: string;
    dateBroadcasted?: IsoDatetime;
    dateConfirmed?: IsoDatetime;
    initiator: Initiator;
    publicKeyId: string;
    orgId: EntityId;
    fee?: Amount;
};
export type GetPublicKeyResponse = {
    id: EntityId;
    externalId?: string;
    publicKey: PublicKey;
    groupThreshold: number;
    groupSize: number;
    tags?: Tag[];
    isEddsa: boolean;
};
export type StartWalletConnectSessionOutput = {
    session: WalletConnectSession;
};
export type WalletConnectClientMeta = {
    name: string;
    description: string;
    icons: string[];
};
export type WalletConnectSession = {
    accounts: string[];
    chainId: IntegerPositiveStrict;
    bridge: string;
    key: string;
    clientId: string;
    clientMeta?: WalletConnectClientMeta;
    peerId: string;
    peerMeta?: WalletConnectClientMeta;
    handshakeId: IntegerPositiveStrict;
    handshakeTopic: string;
};
export type CreateSignatureInput = {
    hash: string;
};
export type CreatePublicKeyInput = {
    externalId?: string;
    assetAccountId?: EntityId;
    groupSize?: number;
    groupThreshold?: number;
    isEddsa: boolean;
    tags?: Tag[];
};
export type CreateWalletTxInput = {
    to: BlockchainAddress;
    amount: Amount;
    asset: string;
};
export type StartWalletConnectSessionInput = {
    wcUri: string;
};
export type TransactionPayload = EvmGenericTx | SolanaTx;
export declare enum PublicKeyStatus {
    Active = "Active",
    Disabled = "Disabled",
    Compromised = "Compromised"
}
export declare enum SignatureStatus {
    Pending = "Pending",
    Executed = "Executed",
    Rejected = "Rejected",
    Failed = "Failed"
}
export declare enum TransactionTemplateKind {
    EvmGenericTx = "EvmGenericTx",
    CosmosIbcTransfer = "CosmosIbcTransfer",
    SolanaTx = "SolanaTx",
    TronTx = "TronTx",
    TezosTx = "TezosTx"
}
export declare enum TransactionStatus {
    Initiated = "Initiated",
    PolicyAccepted = "PolicyAccepted",
    PolicyRejected = "PolicyRejected",
    BroadcastPending = "BroadcastPending",
    BroadcastRejected = "BroadcastRejected",
    Broadcasted = "Broadcasted",
    Confirmed = "Confirmed",
    Failed = "Failed"
}
