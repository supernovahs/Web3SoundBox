"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userActionFetch = exports.simpleFetch = void 0;
const cross_fetch_1 = require("cross-fetch");
const dfnsError_1 = require("../dfnsError");
const baseAuthApi_1 = require("../baseAuthApi");
const nonce_1 = require("./nonce");
const fullUrl = (fetch) => {
    return async (resource, options) => {
        const { baseUrl } = options.apiOptions;
        resource = new URL(resource, baseUrl);
        return fetch(resource, options);
    };
};
const jsonSerializer = (fetch) => {
    return async (resource, options) => {
        var _a;
        if (options.body) {
            options.body = JSON.stringify(options.body);
            options.headers = {
                'content-type': 'application/json',
                ...((_a = options.headers) !== null && _a !== void 0 ? _a : {}),
            };
        }
        return fetch(resource, options);
    };
};
const errorHandler = (fetch) => {
    return async (resource, options) => {
        const response = await fetch(resource, options);
        if (response.ok) {
            return response;
        }
        else {
            const body = await response.json();
            throw new dfnsError_1.DfnsError(response.status, body.error.message, body.error);
        }
    };
};
const dfnsAuth = (fetch) => {
    return async (resource, options) => {
        var _a;
        const { appId, appSecret, authToken } = options.apiOptions;
        const authorization = authToken
            ? {
                authorization: `Bearer ${authToken}`,
            }
            : {};
        const dfnsAppSecret = appSecret
            ? {
                'x-dfns-appsecret': appSecret,
            }
            : {};
        options.headers = {
            'x-dfns-appid': appId,
            'x-dfns-nonce': (0, nonce_1.generateNonce)(),
            ...dfnsAppSecret,
            ...authorization,
            ...((_a = options.headers) !== null && _a !== void 0 ? _a : {}),
        };
        return fetch(resource, options);
    };
};
const userAction = (fetch) => {
    return async (resource, options) => {
        var _a, _b;
        if (options.method !== 'GET') {
            const { challenge, challengeIdentifier, allowCredentials } = await baseAuthApi_1.BaseAuthApi.createUserActionChallenge({
                userActionPayload: (_a = options.body) !== null && _a !== void 0 ? _a : '',
                userActionHttpMethod: options.method,
                userActionHttpPath: resource.pathname,
                userActionServerKind: 'Api',
            }, options.apiOptions);
            const { signer } = options.apiOptions;
            const assertion = await signer.sign(challenge, allowCredentials);
            const { userAction } = await baseAuthApi_1.BaseAuthApi.signUserActionChallenge({
                challengeIdentifier,
                firstFactor: assertion,
            }, options.apiOptions);
            options.headers = {
                'x-dfns-useraction': userAction,
                ...((_b = options.headers) !== null && _b !== void 0 ? _b : {}),
            };
        }
        return fetch(resource, options);
    };
};
exports.simpleFetch = fullUrl(jsonSerializer(dfnsAuth(errorHandler(cross_fetch_1.fetch))));
exports.userActionFetch = fullUrl(jsonSerializer(dfnsAuth(userAction(errorHandler(cross_fetch_1.fetch)))));
